/*
    idea:
    - using trie i store all strings with the end of each string being a set of all the id's having this word
    - the id represents the entry number
    - each time i search/insert a word i return the set of ids of that word
    - i count the number of times each id occurs with the different words so as to check the number of common words between two sets
    - using dsu i combine the sets of strings
    - i keep repeating the process with the resulting vector of strings in case it could be merged more until the input to the function
    and the result are the same(no further merging could be done)
*/
#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

using namespace std;

const int MAXNODE = 100001;
struct DSU {
	int par[MAXNODE];
	DSU() {
		memset(par, -1, sizeof par);
	}

	int getRoot(int v) {
		if(par[v] < 0) return v;
		return par[v] = getRoot(par[v]);
	}

	void merge(int x, int y) {
		x = getRoot(x);
		y = getRoot(y);
		if(x == y) return;
		if(par[y] < par[x])	// balancing the height of the tree
			swap(x, y);
		par[x] += par[y];
		par[y] = x;
	}
};

struct node{
	node *nxt[26];
	set<int>endd;
	node(){
		memset(nxt,NULL,sizeof nxt);
	}
};

class Thesaurus {
public:
	node*root;
	void clr(node*n)
	{
		for(int i=0;i<26;i++)
		{
			if(n->nxt[i])clr(n->nxt[i]);
		}
		delete n;
	}
	void insrt(string s,int id){
		node*cur=root;
		for(int i=0;i<s.length();i++){
			if(!cur->nxt[s[i]-'a'])
				cur->nxt[s[i]-'a']=new node();
			cur=cur->nxt[s[i]-'a'];
		}
		cur->endd.insert(id);
	}
	set<int> srch(string s,int id){
		node*cur=root;
		for(int i=0;i<s.length();i++){
			if(!cur->nxt[s[i]-'a']){
				insrt(s,id);
				return set<int>();
			}
			cur=cur->nxt[s[i]-'a'];
		}
		return cur->endd;
	}
	map<int,set<string>>sep(vector <string>v){
		map<int,set<string>>ret;
		for(int i=0;i<v.size();i++){
			set<string>s;
			int st=0;
			int f=v[i].find(' ');
			bool br=false;
			while(true){
				if(f==-1)f=v[i].length(),br=true;
				string tmp=v[i].substr(st,f-st);
				s.insert(tmp);
				if(br)break;
				st=f+1;
				f=v[i].find(' ',f+1);
			}
			ret[i+1]=s;
		}
		return ret;
	}
	vector <string> edit(vector <string> entry) {
		root=new node();
		vector <string>res;
		vector<int>idss(entry.size()+1);for(int i=1;i<idss.size();i++)idss[i]=i;
		map<int,set<string>>ss=sep(entry);

		int i=1;
		for(map<int,set<string>>::iterator it=ss.begin();it!=ss.end();it++){
			vector<int>v(55);
			for(set<string>::iterator str=it->second.begin();str!=it->second.end();str++){
				set<int>sr=srch(*str,i);
				for(set<int>::iterator itt=sr.begin();itt!=sr.end();itt++){
					v[*itt]++;
				}
			}
			for(int j=0;j<v.size();j++){
				if(v[j]>=2)idss[j]=i;
			}
			i++;
		}
		DSU d;
		for(i=1;i<idss.size();i++){
			if(idss[i]){
				d.merge(i,idss[i]);
			}
		}
		map<int,set<string>>tm;
		for(i=1;i<idss.size();i++){
			if(d.par[i]>0){
				tm[d.par[i]].insert(ss[i].begin(),ss[i].end());
			}
			else tm[i].insert(ss[i].begin(),ss[i].end());
		}
		for(map<int,set<string>>::iterator it=tm.begin();it!=tm.end();it++){
			string tmp="";
			bool sp=false;
			for(set<string>::iterator str=it->second.begin();str!=it->second.end();str++){
				if(sp)tmp+=" ";
				tmp+=*str;
				sp=true;
			}
			res.push_back(tmp);
		}
		sort(res.begin(),res.end());
		clr(root);
		if(res!=entry)res=edit(res);
		return res;
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, vector <string> p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	Thesaurus *obj;
	vector <string> answer;
	obj = new Thesaurus();
	clock_t startTime = clock();
	answer = obj->edit(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "{";
		for (int i = 0; int(p1.size()) > i; ++i) {
			if (i > 0) {
				cout << ",";
			}
			cout << "\"" << p1[i] << "\"";
		}
		cout << "}" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "{";
	for (int i = 0; int(answer.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << answer[i] << "\"";
	}
	cout << "}" << endl;
	if (hasAnswer) {
		if (answer.size() != p1.size()) {
			res = false;
		} else {
			for (int i = 0; int(answer.size()) > i; ++i) {
				if (answer[i] != p1[i]) {
					res = false;
				}
			}
		}
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;

	vector <string> p0;
	vector <string> p1;

	{
		// ----- test 0 -----
		string t0[] = {"ape monkey wrench","wrench twist strain"};
		p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
		string t1[] = {"ape monkey wrench","strain twist wrench"};
		p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
		all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
		// ------------------
	}

	{
		// ----- test 1 -----
		string t0[] = {"ape monkey wrench","wrench twist strain","monkey twist frugue"};
		p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
		string t1[] = {"ape monkey wrench","frugue monkey twist","strain twist wrench"};
		p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
		all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
		// ------------------
	}

	{
		// ----- test 2 -----
		string t0[] = {"ape monkey wrench","wrench twist strain","monkey twist frugue strain"};
		p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
		string t1[] = {"ape frugue monkey strain twist wrench"};
		p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
		all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
		// ------------------
	}

	{
		// ----- test 3 -----
		string t0[] = {"point run score","point dot","cut run tear score","cut valley","cute pretty"};
		p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
		string t1[] = {"cut point run score tear","cut valley","cute pretty","dot point"};
		p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
		all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
		// ------------------
	}

	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!

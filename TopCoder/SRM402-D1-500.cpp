/*
  idea: 
  - first concatinating all strings into one string
  - counting number of consecutive dots and x's and saving them in a vector
  - the main idea is that the vector will have number of dots and x's alternatingly and looping through the x's only 
  and calculating the number of consectutive dots when that x is removed
*/
#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>

using namespace std;


class LargestGap {
public:
	int getLargest(vector <string> board) {
		string s="";
		//-----------------appending--------------------------------
		for(int i=0;i<board.size();i++)s+=board[i];
		vector<pair<int,int> >v;
		bool x=false;
		if(s[0]=='X')x=true;
		for(int i=0;i<s.length();i++){
			int cnt=0;
			int j=i;
			while(i<s.length()&&s[i]=='.')i++,cnt++;
			if(cnt>0)v.push_back(make_pair(cnt,j));
			cnt=0;
			j=i;
			if(i==s.length())break;
			while(i<s.length()&&s[i]=='X')i++,cnt++;
			if(cnt>0)v.push_back(make_pair(cnt,j));
			i--;
		}
		//-------------------accumulating dots-------------------------------
		for(int i=x?3:2;i<v.size();i+=2){
			v[i].first+=v[i-2].first;
		}
		//--------------counting dots when block is removed---------------
		vector<pair<vector<int>,int>>vec;
		for(int i=x?0:1;i<v.size();i+=2){
			vector<int>tmp;
			if(i-3>=0){
				for(int j=x?1:0;j<=i-3;j+=2){
					if(j-2>=0)
						tmp.push_back(v[j].first-v[j-2].first);
					else
						tmp.push_back(v[j].first);
				}
				if(i+1<v.size())
					tmp.push_back(v[i+1].first-v[i-3].first);
				else
					tmp.push_back(v[i-1].first-v[i-3].first);
			}
			else{
				tmp.push_back(v[i+1].first);
			}
			for(int j=i+3;j<v.size();j+=2){
				tmp.push_back(v[j].first-v[j-2].first);
			}
			//------------------first and last are dots-----------------------------
			if((s[s.length()-1]=='.'&&(s[0]=='.'||(x&&i==0)))||(s[0]=='.'&&i==v.size()-1&&s[s.length()-1]=='X')){
				tmp[0]+=tmp[tmp.size()-1],tmp.pop_back();
			}
			//-------------------sorting each case-----------------------------
			sort(tmp.rbegin(),tmp.rend());
			vec.push_back(make_pair(tmp,v[i].second));
		}
		//--------------------end of preprocessing------------------------------
		sort(vec.rbegin(),vec.rend());
		vector<int>res=vec[0].first;
		int ans=vec[0].second;
		for(int i=0;i<vec.size();i++){
			if(vec[i].first==res&&vec[i].second<ans)ans=vec[i].second;
		}
		return ans;
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, int p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	LargestGap *obj;
	int answer;
	obj = new LargestGap();
	clock_t startTime = clock();
	answer = obj->getLargest(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;

	vector <string> p0;
	int p1;

	{
		// ----- test 0 -----
		string t0[] = {".....X.X......."};
		p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
		p1 = 5;
		all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
		// ------------------
	}

	{
		// ----- test 1 -----
		string t0[] = {"XXXX","....","XXXX","....","XXXX","...."};
		p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
		p1 = 0;
		all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
		// ------------------
	}

	{
		// ----- test 2 -----
		string t0[] = {"XXX.........XX...........XX..X"};
		p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
		p1 = 12;
		all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
		// ------------------
	}

	{
		// ----- test 3 -----
		string t0[] = {"XXX","X.....","....XX..XXXXXX","X........X..",".XXX."};
		p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
		p1 = 32;
		all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
		// ------------------
	}

	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!
